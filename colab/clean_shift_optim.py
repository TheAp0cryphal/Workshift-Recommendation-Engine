# -*- coding: utf-8 -*-
"""clean_shift_optim.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lJsWuaCnmuuLx2OPs3il8oYV28jEstav

# End‑to‑End Workforce Shift Optimisation – Clean Re‑Implementation
**Key design decisions**

| area | what we changed | why |
|------|-----------------|-----|
| Environment obs | Each employee contributes 4 numeric features per step:<br> 1 = availability (0/1) for the current block<br> distance / 20 (0‑1)<br> reliability (0‑1)<br> weekly_hours / 50 (0‑1) | Now the policy reasons on actual properties, not on fixed indices → generalises if you shuffle employees. |
| Fairness reward | `‑α · (projected_hours – mean_hours)^2` | Quadratic cost punishes large disparities more strongly. |
| Baselines | (1) Greedy min‑hours tie‑breaker (2) CP‑SAT optimal for a 3‑day miniature | Gives intuitive lower/upper bounds. |
| Metrics | coverage · overtime · avg_dist · Gini | Simple, interpretable. |
| Visuals | Bar of weekly hours, Gini value, heat‑map, distance histogram | Lets you eyeball rule adherence & fairness. |

Run the notebook top‑to‑bottom in Colab; it will:

1. Generate synthetic data that respects the business rules.  
2. Train a PPO policy for 30 k steps (<1 min).  
3. Produce visuals + metrics tables for RL vs Greedy vs CP‑SAT (3‑day).  
4. Save artefacts (`policy.zip`, `weekly_schedule.csv`).

## 1 Setup
"""
print("Starting script: 1. Setup")
import math, random, numpy as np, pandas as pd, matplotlib.pyplot as plt, time, zipfile
from typing import Dict, List
import gymnasium as gym
from gymnasium import spaces
from stable_baselines3 import PPO
from stable_baselines3.common.vec_env import DummyVecEnv
from stable_baselines3.common.callbacks import BaseCallback
from stable_baselines3.common.results_plotter import load_results, ts2xy
from stable_baselines3.common.monitor import Monitor
import os
from ortools.sat.python import cp_model
plt.rcParams['figure.dpi'] = 120
random.seed(0); np.random.seed(0)
print("Setup complete.")

"""## 2 Synthetic Data"""
print("\nStarting: 2. Synthetic Data Generation")
N_EMP = 40
LOCATIONS = {"A":(0,0),"B":(10,0),"C":(0,10),"D":(10,10)}
BLOCKS = ["08-12","12-16","16-20","20-24","00-04","04-08"]

# Generate shift locations for each day and block
def gen_shift_locations():
    shift_locs = {}
    for d in range(7):
        for b_idx, blk in enumerate(BLOCKS):
            # Assign locations in a cyclical pattern to ensure distribution
            loc_key = list(LOCATIONS.keys())[d % 2 * 2 + b_idx % 2]
            shift_locs[f"{d}:{blk}"] = loc_key
    return shift_locs

SHIFT_LOCATIONS = gen_shift_locations()

def gen_employee(pid:int)->Dict:
    loc = random.choice(list(LOCATIONS))
    availability=[]
    for d in range(7):
        for blk in BLOCKS:
            # Lower availability to 40% to make problem harder
            if random.random()<0.4: availability.append(f"{d}:{blk}")
    return {"person_id":pid,
            "location":loc,
            # More variability in reliability
            "reliability":round(random.uniform(0.5,1.0),2),
            "availability":availability,
            "weekly_hours":0}

print("Generating employee data...")
employees = pd.DataFrame([gen_employee(i) for i in range(N_EMP)])
print("Employee data generated.")
employees.head()
print("Synthetic Data Generation complete.")

"""## 3 RL Environment"""
print("\nStarting: 3. RL Environment Setup")
def euclid(loc1:str, loc2:str):
    x1,y1=LOCATIONS[loc1]; x2,y2=LOCATIONS[loc2]
    return math.hypot(x1-x2,y1-y2)

class ShiftEnv(gym.Env):
    def __init__(self, emp_df:pd.DataFrame, fair_w:float=0.1):
        super().__init__()
        self.base=emp_df.copy()
        self.N=len(emp_df)
        self.fair_w=fair_w
        # obs: [day, block_idx, shift_location_x/10, shift_location_y/10] + N*4 features
        self.observation_space=spaces.Box(0,1,shape=(4+self.N*4,),dtype=np.float32)
        self.action_space=spaces.Discrete(self.N)
        self.reset()

    def _make_obs(self):
        feats=[]
        current_shift = f"{self.day}:{BLOCKS[self.block_idx]}"
        shift_loc = SHIFT_LOCATIONS[current_shift]
        shift_x, shift_y = LOCATIONS[shift_loc]
        
        for _,row in self.df.iterrows():
            avail=1.0 if current_shift in row['availability'] else 0.0
            # Calculate distance from employee location to current shift location
            dist=euclid(row['location'], shift_loc)/20
            rel=row['reliability']
            hrs=row['weekly_hours']/50
            feats.extend([avail,dist,rel,hrs])
        return np.array([self.day/6, self.block_idx/5, shift_x/10, shift_y/10]+feats,dtype=np.float32)

    def reset(self,seed=None,options=None):
        super().reset(seed=seed)
        self.df=self.base.copy()
        self.df["weekly_hours"]=0
        self.day,self.block_idx,self.steps=0,0,0
        self.schedule=[]
        return self._make_obs(),{}

    def step(self,action:int):
        emp=self.df.iloc[action]
        block_hours=4
        shift=f"{self.day}:{BLOCKS[self.block_idx]}"
        shift_loc = SHIFT_LOCATIONS[shift]

        reward=0.0
        # availability
        reward+=1 if shift in emp['availability'] else -1
        # overtime
        proj=emp['weekly_hours']+block_hours
        if proj>50 or proj>12: reward-=2
        # distance - calculate from employee location to current shift location
        reward-=euclid(emp['location'], shift_loc)/10
        # reliability
        reward+=emp['reliability']*0.5
        # fairness term
        mean_hrs=self.df['weekly_hours'].mean()
        reward-=self.fair_w*((proj-mean_hrs)**2)/100

        # update
        self.df.at[emp.name,'weekly_hours']=proj
        self.schedule.append((emp['person_id'],self.day,BLOCKS[self.block_idx], shift_loc))
        self.steps+=1
        self.block_idx=(self.block_idx+1)%6
        if self.block_idx==0: self.day=(self.day+1)%7
        done=self.steps>=42
        return self._make_obs(),reward,done,False,{}

# quick test env
print("Testing ShiftEnv...")
_ = ShiftEnv(employees)
print("ShiftEnv test complete.")
print("RL Environment Setup complete.")

"""## 4 Training"""
print("\nStarting: 4. Training")

# Create log directory
log_dir = "training_logs/"
os.makedirs(log_dir, exist_ok=True)

# Create a callback to track rewards
class RewardCallback(BaseCallback):
    def __init__(self, verbose=0):
        super().__init__(verbose)
        self.rewards = []
        self.episode_rewards = []
        self.current_episode_reward = 0

    def _on_step(self):
        # Get the reward for the current step
        reward = self.training_env.buf_rews[0]
        self.current_episode_reward += reward
        self.rewards.append(reward)
        
        # If the episode is done, record the total episode reward
        done = self.training_env.buf_dones[0]
        if done:
            self.episode_rewards.append(self.current_episode_reward)
            self.current_episode_reward = 0
        
        return True

# Wrap the environment with a Monitor
env = Monitor(ShiftEnv(employees), log_dir)
env = DummyVecEnv([lambda: env])

print("Creating PPO model...")
model = PPO('MlpPolicy', env, verbose=0, policy_kwargs=dict(net_arch=[128,128]), device='cpu')

# Create the callback
reward_callback = RewardCallback()

print("Starting model training (30,000 timesteps)...")
model.learn(total_timesteps=30_000, callback=reward_callback)
print("Model training complete.")

# Plot the reward progression
print("Plotting training rewards...")
plt.figure(figsize=(10, 5))

# Plot step rewards
plt.subplot(1, 2, 1)
plt.plot(reward_callback.rewards)
plt.title('Reward per Step')
plt.xlabel('Training Step')
plt.ylabel('Reward')
plt.grid()

# Plot episode rewards
plt.subplot(1, 2, 2)
plt.plot(reward_callback.episode_rewards)
plt.title('Reward per Episode')
plt.xlabel('Episode')
plt.ylabel('Total Episode Reward')
plt.grid()

plt.tight_layout()
plt.savefig('training_rewards.png')
plt.show()
print("Training reward plots generated.")

print("Saving model...")
model.save('policy')
print("Model saved as policy.zip (or policy if zipping fails).")
print("Training complete.")

"""## 5 Roll‑out & Schedule"""
print("\nStarting: 5. Roll-out & Schedule Generation")
eval_env=ShiftEnv(employees)
obs,_=eval_env.reset(); done=False
print("Performing roll-out with trained model...")
while not done:
    act,_=model.predict(obs,deterministic=True)
    obs,_,done,_,_=eval_env.step(int(act))
print("Roll-out complete.")

sched=pd.DataFrame(eval_env.schedule,columns=['person_id','day','block','shift_loc'])
sched['step']=sched.apply(lambda r:r.day*6+BLOCKS.index(r.block),axis=1)
print("Saving weekly schedule...")
sched.to_csv('weekly_schedule.csv',index=False)
print("Weekly schedule saved to weekly_schedule.csv.")
sched.head()
print("Roll-out & Schedule Generation complete.")

"""## 6 Baselines"""
print("\nStarting: 6. Baselines Generation")

def greedy(emp_df):
    print("Starting Greedy baseline calculation...")
    hrs={pid:0 for pid in emp_df.index}
    sc=[]
    for d in range(7):
        for blk in BLOCKS:
            step=d*6+BLOCKS.index(blk)
            shift = f"{d}:{blk}"
            shift_loc = SHIFT_LOCATIONS[shift]
            avail=emp_df[emp_df['availability'].apply(lambda a:shift in a)]
            avail=avail.sort_values('weekly_hours')
            chosen=None
            for pid,row in avail.iterrows():
                if hrs[pid]+4<=50:
                    chosen=pid; break
            if chosen is not None:
                sc.append((chosen,d,blk,shift_loc,step))
                hrs[chosen]+=4
                emp_df.at[chosen,'weekly_hours']=hrs[chosen]
    print("Greedy baseline calculation complete.")
    return pd.DataFrame(sc,columns=['person_id','day','block','shift_loc','step'])

greedy_sched=greedy(employees.copy().set_index('person_id'))

# 3-day optimal small instance
def cp_opt(emp_df,days=7):
    print("Starting CP-SAT optimal baseline calculation (3-day)...")
    model=cp_model.CpModel()
    blocks=list(range(days*6))
    E=list(emp_df.index)
    x={(e,b): model.NewBoolVar(f"x_{e}_{b}") for e in E for b in blocks}
    for b in blocks:
        model.Add(sum(x[(e,b)] for e in E)==1)
    for e in E:
        model.Add(sum(x[(e,b)] for b in blocks)*4<=50)
    for e,row in emp_df.iterrows():
        av=set(row['availability'])
        for b in blocks:
            d=b//6; blk=BLOCKS[b%6]
            if f"{d}:{blk}" not in av: model.Add(x[(e,b)]==0)
    obj=[]
    for e,row in emp_df.iterrows():
        for b in blocks:
            d=b//6; blk=BLOCKS[b%6]
            shift = f"{d}:{blk}"
            shift_loc = SHIFT_LOCATIONS[shift]
            # Update objective function to consider distance to shift location
            obj.append((row['reliability']*10 - euclid(row['location'], shift_loc))*x[(e,b)])
    model.Maximize(sum(obj))
    solver=cp_model.CpSolver(); solver.parameters.max_time_in_seconds=10
    solver.Solve(model)
    sch=[]
    for e in E:
        for b in blocks:
            if solver.Value(x[(e,b)]):
                d=b//6; blk=BLOCKS[b%6]
                shift = f"{d}:{blk}"
                shift_loc = SHIFT_LOCATIONS[shift]
                sch.append((e,d,blk,shift_loc,b))
    print("CP-SAT optimal baseline calculation complete.")
    return pd.DataFrame(sch,columns=['person_id','day','block','shift_loc','step'])

opt_sched=cp_opt(employees.copy().set_index('person_id'))
print("Baselines Generation complete.")

"""## 7 Metrics + Visuals"""
print("\nStarting: 7. Metrics + Visuals Generation")

def gini(arr):
    v=np.sort(arr)
    n=len(v)
    if n==0: return 0
    cum=np.cumsum(v)
    return (n+1-2*np.sum(cum)/cum[-1])/n

def metrics(df,emp_df):
    if df.empty: return {}
    hours=df.groupby('person_id').size()*4
    coverage=len(df)/df['step'].nunique()
    overtime=(hours>50).sum()
    
    # Calculate distance from employee to assigned shift location
    dists=[]
    for i, row in df.iterrows():
        emp_loc = emp_df.loc[row['person_id'],'location']
        shift_loc = row['shift_loc']
        dists.append(euclid(emp_loc, shift_loc))
    
    scheduled_reliabilities = [emp_df.loc[pid,'reliability'] for pid in df['person_id']]
    return {'coverage':round(coverage,3),
            'overtime':int(overtime),
            'avg_dist':round(np.mean(dists),2),
            'total_dist':round(sum(dists),2),
            'max_dist':round(max(dists),2) if dists else 0,
            'gini':round(gini(hours.values),3),
            'std_weekly_hours':round(hours.std(),3) if not hours.empty else 0,
            'unique_employees_scheduled':int(hours.count()),
            'avg_reliability_scheduled':round(np.mean(scheduled_reliabilities),3) if scheduled_reliabilities else 0}

print("Calculating metrics for RL schedule...")
met_rl=metrics(sched,employees.set_index('person_id'))
print("Calculating metrics for Greedy schedule...")
met_g=metrics(greedy_sched,employees.set_index('person_id'))
print("Calculating metrics for CP-SAT schedule...")
met_opt=metrics(opt_sched,employees.set_index('person_id'))

import pandas as pd, matplotlib.pyplot as plt
comp=pd.DataFrame([met_rl,met_g,met_opt],index=['RL','Greedy','CP-SAT'])
print("\nComparison Metrics:")
print(comp)

# Add more visualizations to compare methods

# 1. Bar of weekly hours - show all methods
print("\nGenerating 'Weekly Hours Comparison' bar chart...")
# Get hours for each method
hrs_rl = sched.groupby('person_id').size()*4
hrs_greedy = greedy_sched.groupby('person_id').size()*4
hrs_opt = opt_sched.groupby('person_id').size()*4

# Create a combined dataframe for all employees
all_emp = sorted(list(set(hrs_rl.index) | set(hrs_greedy.index) | set(hrs_opt.index)))
hrs_combined = pd.DataFrame(index=all_emp)
hrs_combined['RL'] = hrs_rl.reindex(all_emp, fill_value=0)
hrs_combined['Greedy'] = hrs_greedy.reindex(all_emp, fill_value=0)
hrs_combined['CP-SAT'] = hrs_opt.reindex(all_emp, fill_value=0)

plt.figure(figsize=(12,6))
hrs_combined.plot(kind='bar')
plt.axhline(50, ls='--', color='red', label='Max Hours')
plt.title('Weekly Hours per Person - All Methods')
plt.legend()
plt.tight_layout()
plt.savefig('hours_comparison.png')
plt.show()
print("Weekly hours comparison chart generated.")

# 2. Distance distribution
print("\nGenerating 'Distance Distribution' charts...")
plt.figure(figsize=(12,5))

# Create distance histograms
distances = {}
for i, row in sched.iterrows():
    emp_loc = employees.set_index('person_id').loc[row['person_id'],'location']
    shift_loc = row['shift_loc']
    distances.setdefault('RL', []).append(euclid(emp_loc, shift_loc))
    
for i, row in greedy_sched.iterrows():
    emp_loc = employees.set_index('person_id').loc[row['person_id'],'location']
    shift_loc = row['shift_loc']
    distances.setdefault('Greedy', []).append(euclid(emp_loc, shift_loc))

for i, row in opt_sched.iterrows():
    emp_loc = employees.set_index('person_id').loc[row['person_id'],'location']
    shift_loc = row['shift_loc']
    distances.setdefault('CP-SAT', []).append(euclid(emp_loc, shift_loc))

plt.subplot(131)
plt.hist(distances['RL'], bins=10, alpha=0.7)
plt.title('RL Distance Distribution')
plt.xlabel('Distance')
plt.ylabel('Count')

plt.subplot(132)
plt.hist(distances['Greedy'], bins=10, alpha=0.7)
plt.title('Greedy Distance Distribution')
plt.xlabel('Distance')

plt.subplot(133)
plt.hist(distances['CP-SAT'], bins=10, alpha=0.7)
plt.title('CP-SAT Distance Distribution')
plt.xlabel('Distance')

plt.tight_layout()
plt.savefig('distance_distribution.png')
plt.show()
print("Distance distribution charts generated.")

# 3. Reliability comparison
print("\nGenerating 'Reliability Distribution' charts...")
plt.figure(figsize=(12,5))

# Create reliability histograms
reliability = {}
for i, row in sched.iterrows():
    rel = employees.set_index('person_id').loc[row['person_id'],'reliability']
    reliability.setdefault('RL', []).append(rel)
    
for i, row in greedy_sched.iterrows():
    rel = employees.set_index('person_id').loc[row['person_id'],'reliability']
    reliability.setdefault('Greedy', []).append(rel)

for i, row in opt_sched.iterrows():
    rel = employees.set_index('person_id').loc[row['person_id'],'reliability']
    reliability.setdefault('CP-SAT', []).append(rel)

plt.subplot(131)
plt.hist(reliability['RL'], bins=10, alpha=0.7)
plt.title('RL Reliability Distribution')
plt.xlabel('Reliability')
plt.ylabel('Count')

plt.subplot(132)
plt.hist(reliability['Greedy'], bins=10, alpha=0.7)
plt.title('Greedy Reliability Distribution')
plt.xlabel('Reliability')

plt.subplot(133)
plt.hist(reliability['CP-SAT'], bins=10, alpha=0.7)
plt.title('CP-SAT Reliability Distribution')
plt.xlabel('Reliability')

plt.tight_layout()
plt.savefig('reliability_distribution.png')
plt.show()
print("Reliability distribution charts generated.")

# 4. Fairness metrics comparison
print("\nGenerating 'Fairness Metrics' comparison...")
plt.figure(figsize=(8,5))
fairness = pd.DataFrame({
    'Gini Coefficient': [met_rl['gini'], met_g['gini'], met_opt['gini']],
    'Std Dev Hours (normalized)': [met_rl['std_weekly_hours']/50, met_g['std_weekly_hours']/50, met_opt['std_weekly_hours']/50]
}, index=['RL', 'Greedy', 'CP-SAT'])

fairness.plot(kind='bar')
plt.title('Fairness Metrics Comparison')
plt.ylabel('Value (lower is more fair)')
plt.tight_layout()
plt.savefig('fairness_comparison.png')
plt.show()
print("Fairness metrics comparison generated.")

# heatmap
print("Generating 'RL Schedule Heat-map'...")
uniq=sorted(sched['person_id'].unique())
mat=np.zeros((len(uniq),42))
rowmap={pid:i for i,pid in enumerate(uniq)}
for r in sched.itertuples(index=False):
    mat[rowmap[r.person_id], r.step]=1
plt.figure(figsize=(8,4)); plt.imshow(mat,aspect='auto'); plt.title('RL Schedule Heat‑map'); plt.xlabel('Step'); plt.ylabel('Employee'); plt.savefig('rl_heatmap.png'); plt.show()
print("Heat-map generated.")

# Add heat maps for Greedy and CP-SAT
print("Generating comparison heat maps...")
# Greedy heatmap
uniq_g=sorted(greedy_sched['person_id'].unique())
mat_g=np.zeros((len(uniq_g),42))
rowmap_g={pid:i for i,pid in enumerate(uniq_g)}
for r in greedy_sched.itertuples(index=False):
    mat_g[rowmap_g[r.person_id], r.step]=1

# CP-SAT heatmap (partial for 3 days = 18 blocks)
uniq_opt=sorted(opt_sched['person_id'].unique())
mat_opt=np.zeros((len(uniq_opt),18))  # Only 3 days = 18 blocks
rowmap_opt={pid:i for i,pid in enumerate(uniq_opt)}
for r in opt_sched.itertuples(index=False):
    if r.step < 18:  # Ensure we only plot blocks within the CP-SAT range
        mat_opt[rowmap_opt[r.person_id], r.step]=1

plt.figure(figsize=(12,10))
plt.subplot(311)
plt.imshow(mat,aspect='auto')
plt.title('RL Schedule Heat-map')
plt.ylabel('Employee')
plt.xticks([])

plt.subplot(312)
plt.imshow(mat_g,aspect='auto')
plt.title('Greedy Schedule Heat-map')
plt.ylabel('Employee')
plt.xticks([])

plt.subplot(313)
plt.imshow(mat_opt,aspect='auto')
plt.title('CP-SAT Schedule Heat-map (3-day)')
plt.xlabel('Step')
plt.ylabel('Employee')

plt.tight_layout()
plt.savefig('schedule_heatmaps.png')
plt.show()
print("Comparison heat maps generated.")

print("Metrics + Visuals Generation complete.")

"""## 8 Save Artefacts"""
print("\nStarting: 8. Save Artefacts")
# print("Attempting to save artefacts (policy.zip and weekly_schedule.csv)...")
# with zipfile.ZipFile('artefacts.zip','w') as zf:
#     zf.write('policy.zip' if os.path.exists('policy.zip') else 'policy')
#     zf.write('weekly_schedule.csv')
# print('Saved artefacts.zip')
print("Save Artefacts section currently commented out. No artefacts will be zipped beyond individual file saves.")
print("\nScript finished.")